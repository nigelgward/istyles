%% February 2020 - May 2021, Nigel Ward 
%% From interaction style parameter values for hundreds of audio tracks,
%%  build and/or apply the space of interaction styles 

%% PcbStatsFile is the prosodic-constructions-binned file generated by computeStyleParams
%% makeNewSpace if true means to compute and write normalization stats and PCA coeff
%%         that is, to create a new space
%%    if false means to use existing normalization stats and PCA coeff
%%         that is, read a space description, and analyze audio with respect to it
%% IsNormRotStatsFile is the file to write the above, or to read it from 

%% in either case, the following step will be to bash the sox-xxx.sh files
%%   and either anlyze the resulting clips or use them as stimuli

%% Run this in the istyles top directory, for example
%%  deriveISspace('pcdstats/train-30sec.csv', true, 'trainIsNormRot.mat', 'trainset-out');
%%  deriveISspace('pcdstats/test2Stats.csv', false, 'trainIsNormRot.mat', 'testset-out');


function deriveISspace(PcbStatsFile, makeNewSpace, ISNormRotStatsFile, outputDir)

  addpath('c:/nigel/midlevel/src');
  basedir = 'c:/nigel/istyles/';
  %%statsFile = [basedir 'shortTests/ministats.csv'];
  statsFile = PcbStatsFile;  
  outDir = [basedir outputDir, '/'];

  data = readmatrix(statsFile);   % one row per audio track
  sourceInfo = data(:,1:NSourceInfoFields()); 
  sstats = data(:,1+NSourceInfoFields():end);   % the statistics for each side 
  fprintf('found data for %d clips, %d features, with %d NaNs\n', ...
  	  size(sstats), sum(sum(isnan(sstats))) );
  featNames = assembleLabels();   % feature names 

  %[sstats, sourceInfo, featNames] = pruneJunk(sstats, sourceInfo, featNames);
  %%[sstats, sourceInfo] = pruneExcessives(sstats, sourceInfo, featNames);
  fprintf('Reporting results over %d clips\n', size(sstats, 1));

  cmatrix = corrcoef(sstats);
  fprintf(' found %d NaNs in the correlations\n', sum(sum(isnan(cmatrix))));
%  writeCorrelations(cmatrix, featNames, outDir, 'correlations.txt');

  if makeNewSpace
    fmean = mean(sstats);
    fstd = std(sstats);
    normalized = (sstats - fmean) ./ fstd;
    [coeff, score, latent] = pca(normalized);

    loadingsHeader = sprintf('Interaction Style Dimension Loadings, generated %s', ...
			     datestr(clock));
    writeLoadings(coeff, featNames, loadingsHeader, outDir);
    writeLoadingsTable(coeff, featNames, loadingsHeader, outDir);
    provenance = ['deriveISspace ' PcbStatsFile ' ' datestr(clock)];
    save(ISNormRotStatsFile, 'fmean', 'fstd', 'coeff', 'provenance');
    printVariExplained(latent);
  else
    load(ISNormRotStatsFile);
    normalizedf = (sstats - fmean) ./ fstd;
    score = normalizedf * coeff;
  end
  
  %%warnReExcessives(score, sstats, sourceInfo, featNames);
%nigel  score = score(:,1:16);    %%trim down to save space

  writeScores(score, sourceInfo, outDir);   
  
  metad = assembleMetadata(basedir, sourceInfo);
  
  computeTopicAverages(score, metad);
  return;    %!!!temporary
  findTopicTendencies(score, metad);


  examineMaleFemale(score, metad);
  examineAge(score, metad);
  examineStage(score, metad); 
  examineAB(score, metad);

  %wordFreqAnalysis(score, metad);  % takes aout 2 hours for trainset

%%  hold on   % create a visualization of the interaction style space%%
  scatter(score(:,1),score(:,2), 1);
%%  scatter(0,0,10,'k');

  soxCmdfilePath = sprintf('%smanySoxCmds.sh', outDir);
  soxfd = fopen(soxCmdfilePath, 'w');      % to later execute with bash
%  findClipsNearOrigin(score, sourceInfo, metad, soxfd);  
  pickClipsForHumanSubjects(score, sourceInfo, metad, outDir, PcbStatsFile);
  pickClipsForExamination(score, sourceInfo, metad, soxfd);
  examinePredictability(score, metad);

%  writeSomeClosePairs(score, sourceInfo, metad);  % a trifle slow 
%  compareWithSubsets(coeff, normalized);  % a trifle verbose


  fclose(soxfd);
end


function computeTopicAverages(score, metad)
  score = score(:,1:8);
  %score(:,2) = .2 * abs(score(:,2));
  %score(:,4) = .2 * abs(score(:,4));
  minDialogsPerTopicInOrderToAnalyze = 100;  % was 50
  minDistanceFromOrigin = 1.05;  % to select the 20 most non-generic topics
  %minDistanceFromOrigin = 1.8   % suitable if do the abs above
  firstTopic = min(metad(:,8));
  lastTopic =  max(metad(:,8));
  nextValidTopicIx = 1;
%  topicMeans = zeros(1,8);
  for topic = firstTopic:lastTopic
    indicesForTopic = metad(:,8) == topic;
    scoresForTopic = score(indicesForTopic,:);
    if size(scoresForTopic,1) < minDialogsPerTopicInOrderToAnalyze
      continue
    end
    dimAvgs = mean(scoresForTopic(:,:));
    if sum(dimAvgs.^2) < minDistanceFromOrigin
      continue
    end
    topicNumbers(nextValidTopicIx) = topic;
    topicMeans(nextValidTopicIx, :) = dimAvgs;
    nextValidTopicIx = nextValidTopicIx + 1;
  end
  plotTopics(topicMeans, topicNumbers)
  reportSomeClosePairs(topicMeans, topicNumbers);
end

function plotTopics(topicMeans, topicNumbers)
  clf
  x = topicMeans(:,1);
  y = topicMeans(:,3);
  scatter(x, y);
  labels = {};
  for i = 1:length(topicNumbers)
    labels(end+1) = {lower(topicName(topicNumbers(i)))}
  end 
  text(x+.05, y+.05, labels);
  xlabel('both participants engaged ... lack of shared engagement');
  ylabel('positive assessment ... negative feelings');
  xlim([-2, 2]);
  ylim([-2, 2]);
end


%% prints out the pairs of topics with the closest means
function reportSomeClosePairs(locations, ids)
  npoints = size(locations,1);
  fprintf('out of %d topics that meet the criteria\n', npoints);
  for i = 1:npoints
    for j = 1:npoints
      distances(i,j) = euclidean(locations(i,:), locations(j,:));
    end
  end
  findClosePairsInner(locations, ids, distances, 'similar');
  fprintf('\n')
  findClosePairsInner(locations, ids, -distances, 'dissimilar');
end

function findClosePairsInner(locations, ids, distances, label)
  notMinFlag = 1 + max(distances(:));
  for column = 1:size(distances, 1);
    distances(column,column) = notMinFlag;  % exclude the diagonal
  end

  for minCounter = 1:10
    minDistance = min(distances(:));
    [minrow,mincol] = find(distances == minDistance);
    for k = 1:2:min(10,length(minrow))
      fprintf('%dth most %s topics are %s and %s\n', ...
	      minCounter, label, topicName(ids(minrow(k))), topicName(ids(mincol(k))) );
      printEightNumbers(' ', locations(minrow(k),:));
      printEightNumbers(' ', locations(mincol(k),:));
      distances(minrow(k), mincol(k)) = notMinFlag;
      distances(mincol(k), minrow(k)) = notMinFlag;
    end
  end
end


function findTopicTendencies(score, metad)
  alphaMeans = 0.0000000001;  
  alphaStds =  0.00000000001; 
  firstTopic = min(metad(:,8));
  lastTopic =  max(metad(:,8));
  %topicInfo = readmatrix('/cygdrive/f/nigel/comparisons/en-swbd/ldc-docs/topic_tab.csv');
 
  for dim = 1:8
    for topic = firstTopic:lastTopic
      indicesForTopic = metad(:,8) == topic;
      indicesForOther = metad(:,8) ~= topic;
      scoresForTopic = score(indicesForTopic, dim);
      scoresForOther = score(indicesForOther, dim);
      if length(scoresForTopic) < 10
	continue
      end
      if ttest2(scoresForTopic,scoresForOther, 'Alpha', alphaMeans) 
	fprintf('dimension %d, topic %d %s, mean %.2f\n', ...
		dim, topic, topicName(topic), mean(scoresForTopic));
      end
                                                        
      if ttest2(scoresForTopic.^2,scoresForOther.^2, 'Alpha', alphaStds)
	fprintf('dimension %d, topic %d %s, mean sq this %.2f, mean sq other %.2f\n', ...
		dim, topic, topicName(topic), ...
		mean(scoresForTopic.^2), mean(scoresForOther.^2));
      end
    end
  end
end

function name = topicName(topic)
  command = sprintf('grep %d c:/nigel/switchboard/topic_tab.csv | cut -f 1 -d , > tmp.tmp', topic);
  system(command);
  name = fgetl(fopen('tmp.tmp'));
end 




function [sstats, sourceInfo, featNames] = pruneJunk(sstats, sourceInfo, featNames)
  %%fprintf('size of sstats is %d x %d, with %d NaNs\n', ...
  %%	  size(sstats), sum(sum(isnan(sstats))) );
  %% Formerly had a bug where with many zero-rich lines on
  %% prosody-derived features, so detect and remove such lines.
  nonZeroRows = sum(sstats(:,1+NSourceInfoFields:end), 2) > 0;
  sstats = sstats(nonZeroRows,:);
  sourceInfo = sourceInfo(nonZeroRows,:);

  %% Formerly some prosodic dimensions had less variation that expected, so
  %% the outlier-region features were constantly zero, so exclude them
  nonZeroColumns = sum(sstats, 1) > 0;
  for i = 1:length(featNames)
    if sum(sstats(:,i)) == 0
      fprintf('always zero for: %s\n', labelString(i, featNames));
    end
  end
  sstats = sstats(:, nonZeroColumns);

  %% fprintf('size of twice-pruned sstats is %d x %d\n', size(sstats));
  featNames = featNames(:, nonZeroColumns);
end 


%% write, also display some statistics and some samples as a sanity check
function writeScores(score, sourceInfo, outDir)
  maxTracksToShow = 5;  
  nclips = size(sourceInfo,1);
  tracksToShow = min(nclips, maxTracksToShow);
  dimsToShow = 8;
  means = mean(score);
  stds = std(score);
  fprintf('  dim      %4d %4d %4d %4d   %4d %4d %4d %4d  \n', 1:dimsToShow);
  fprintf('  mean      %4.1f %4.1f %4.1f %4.1f   %4.1f %4.1f %4.1f %4.1f  \n', ...
	  means(1:dimsToShow));
  fprintf('  stdevs    %4.1f %4.1f %4.1f %4.1f   %4.1f %4.1f %4.1f %4.1f  \n', ...
	  stds(1:dimsToShow));
  fprintf('      dim scores for a few sample clips\n');
  for track = 1:tracksToShow
    fprintf('%s : %4.1f %4.1f %4.1f %4.1f   %4.1f %4.1f %4.1f %4.1f  \n', ...
	    sourceString(track, sourceInfo), score(track, 1:dimsToShow))
  end

  sfd = fopen([outDir 'scores.txt'], 'w');
  fprintf(sfd, 'scores %s', datestr(clock));
  for track = 1:nclips
    fprintf(sfd,'%s : %4.1f %4.1f %4.1f %4.1f   %4.1f %4.1f %4.1f %4.1f  \n', ...
	    sourceString(track, sourceInfo), score(track, 1:dimsToShow));
  end
  fclose(sfd);
end


function printVariExplained(latent)
  nToShow = 12;
  fprintf('dim                    %4d %4d %4d %4d %4d %4d %4d %4d %4d %4d %4d %4d\n', ...
	  1:nToShow)
  ve = latent ./ sum(latent);
  fprintf('Variance Explained:    %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f\n', ...
	  ve(1:nToShow));
  cve = cumsum(latent) ./ sum(latent);
  fprintf('Cummulative Explained: %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f\n', ...
	  cve(1:nToShow ));
end



%% return a human-readable string 
function trackString = sourceString(trackNum, sourceInfo)
  fileName = sourceInfo(trackNum, 1);
  trackCode = trackLetter(sourceInfo(trackNum, 2));
  clipStr   = clipString(sourceInfo(trackNum, 3));
  trackString = sprintf('  %d-%s-%s', fileName, trackCode, clipStr);   
end


function str = clipString(clipnum)
  startSeconds = 30 * (clipnum - 1);
  endSeconds = 30 * clipnum;
  str = sprintf('%1d:%02d-%1d:%02d', ...
		floor(startSeconds/60), rem(startSeconds,60), ...
		floor(endSeconds/60), rem(endSeconds,60) );
end


function track = trackLetter(channelNum)
  if channelNum == 0
    track = 'l';
  else
    track = 'r';
  end
end

  
function findClipsNearOrigin(score, sourceInfo, metad, soxfd)
  Eight = 8;     % dimensions I trust
  Twelve = 12;   % a few more, for comparison

  distancesFromZero =  sqrt(sum(score(:,1:Eight) .* score(:,1:Eight),2));
  fprintf('\n Closest 5 tracks to the origin, computed over 8 dimensions');
  [vals, sortIndices] = sort(distancesFromZero);
  for i=1:5
    fprintf('\n        %s', sourceString(sortIndices(i), sourceInfo));
    clipnum = metad(sortIndices(i), 4);
    startSeconds = 30 * (clipnum - 1);
    wavFileName = metad(sortIndices(i), 2);
    fprintf('selecting %s starting %d as anchor %d\n', ...
	    wavFilePath(wavFileName), startSeconds, i);
    fprintf('near-origin-clip''s dimvals')
    fprintf(' %.2f', score(sortIndices(i),1:8));
    fprintf(soxfd, 'sox %s anchor%d.wav trim 0:%d 0:30 fade 0 -1 0.01\n', ...
	    wavFilePath(wavFileName), i, startSeconds);
  end

  [maxDistance, ix] = max(distancesFromZero);
  fprintf('\nThe track farthest from the origin by 8 is %s', ...
	  sourceString(ix, sourceInfo));

  distancesFromZero12 =  sqrt(sum(score(:,1:Twelve) .* score(:,1:Twelve),2));
  [minDistance, ix] = min(distancesFromZero12);
  fprintf('\nThe track closest to the origin by 12 is %s\n\n',  ... 
	  sourceString(ix, sourceInfo));
end 


%% slow 
function writeSomeClosePairs(score, sourceInfo, metad)
  Eight = 8;     % dimensions I trust
  distancesHeader8  = sprintf('--- distances etc using %d dimensions---', Eight);
  writeSomeClosePairsBis(score(:,1:Eight),  sourceInfo, metad, distancesHeader8);
  writeSomeClosePairsBis(score(:,:),  sourceInfo, metad, 'with all 84 dimensions');
end

%% with 8 dimensions
% 2172-4-4:00 and 2086-l-4:30: reminiscing, mixed memories, other supportive
% 2272-l-00 and 2113-r-00 jumping right in, directly addressing the assigned topic, mostly a monolog, with the other just saying yes
% 2439-r-1:00 and 2282-1:00 explaining political/sales situations they both know about, and agreeing

%% with all dimensions
% 2246-l@0:30 and 2240:4@1:30 totally boring the other guy, similar voices, accents
% 2246-l-7:30 and 2196-4@8:30 ditto
% 2268-r!1:30 and 2194-r@5:30 boring mostly monolog


%% clumsily coded; might rewrite this to use the core of reportSomeClosePairs()
function writeSomeClosePairsBis(score, sourceInfo, metad, header)  
  fprintf('\n%s', header);
  nsides = size(score, 1);
  nfeatures = size(score, 2);

  nsides = floor(nsides / 8); % needed since an 8GB array exhausts my kitchen computer memory
  metad = metad(1:nsides,:);
  score = score(1:nsides,:);
  sourceInfo = sourceInfo(1:nsides,:);
  
  for i = 1:nsides
    for j = 1:nsides
      distances(i,j) = euclidean(score(i,:), score(j,:));
    end
  end
  fprintf('   average distance between two pairs: %.2f\n', mean(mean(distances)));

  notMinFlag = 1 + max(distances(:));
  %% if two fragments have the same speaker, it doesn't qualify
  %% (currently only checks for same speaker in same channel)
  for column = 1:nsides
    speaker = metad(column, 5);  % 5 is the speaker field
    sameSpeakerSameChannelVec = (metad(:,5) == speaker);   
    distances(column,sameSpeakerSameChannelVec) = notMinFlag;
    dialogID = metad(column, 2);
    sameDialogVec = (metad(:,2) == dialogID);   
    distances(column,sameDialogVec) = notMinFlag;
  end

  minDistance1 = min(distances(:));
  fprintf('   minimum distance between two pairs: %.2f\n', minDistance1);
  [minrow, mincol] = find(distances==minDistance1);

  for i = 1:min(10,length(minrow))
    fprintf('most similar sides are  %s  and  %s  \n', ...
	    sourceString(minrow(i), sourceInfo), sourceString(mincol(i), sourceInfo));
  end

  %% now find another 
  distances(minrow, mincol) = notMinFlag;
  distances(mincol, minrow) = notMinFlag;

  minDistance2 = min(distances(:));
  fprintf('   second minimum distance between two pairs: %.2f\n', minDistance2);
  [minrow, mincol] = find(distances==minDistance2);

  for i = 1:min(10,length(minrow))
    fprintf('second most similar sides are  %s  and  %s  \n', ...
	    sourceString(minrow(i), sourceInfo), sourceString(mincol(i), sourceInfo));
  end

  %% now find yet another 
  distances(minrow, mincol) = notMinFlag;
  distances(mincol, minrow) = notMinFlag;

  minDistance2 = min(distances(:));
  fprintf('   third minimum distance between two pairs: %.2f\n', minDistance2);
  [minrow, mincol] = find(distances==minDistance2);

  for i = 1:min(10,length(minrow))
    fprintf('third most similar sides are  %s  and  %s  \n', ...
	    sourceString(minrow(i), sourceInfo), sourceString(mincol(i), sourceInfo));
  end

  %% now find a fourth
  distances(minrow, mincol) = notMinFlag;
  distances(mincol, minrow) = notMinFlag;

  minDistance2 = min(distances(:));
  fprintf('   third minimum distance between two pairs: %.2f\n', minDistance2);
  [minrow, mincol] = find(distances==minDistance2);

  for i = 1:min(10,length(minrow))
    fprintf('fourth most similar sides are  %s  and  %s  \n', ...
	    sourceString(minrow(i), sourceInfo), sourceString(mincol(i), sourceInfo));
  end

  %% now find a fifth
  distances(minrow, mincol) = notMinFlag;
  distances(mincol, minrow) = notMinFlag;
  minDistance2 = min(distances(:));
  fprintf('   third minimum distance between two pairs: %.2f\n', minDistance2);
  [minrow, mincol] = find(distances==minDistance2);
  for i = 1:min(10,length(minrow))
    fprintf('fifth most similar sides are  %s  and  %s  \n', ...
	    sourceString(minrow(i), sourceInfo), sourceString(mincol(i), sourceInfo));
  end


end


function distance = euclidean(vec1, vec2)
  deltas = abs(vec1 - vec2);
  distance = sqrt(sum(deltas .* deltas));
end


%% For the experiments, apply this to tracks NOT in the training set.
%% Each line of the predictions file will contain something like:
%% mturk-set1-06.wav, dim1score, dim2score,  ..., dim8score,
%%    , clip source, dimension chosen for, high/low, percentile
%% Note that the anchors are generated above, in findClipsNearOrigin.
%% "mt" here is short for mTurk
function pickClipsForHumanSubjects(score, sourceInfo, metad, outDir, sourceFile)
  rng(0);   % fix the random seed, to get the same permutations on reruns
  nsets = 4; % create 4 sets of stimuli

  mtSoxFile = sprintf('%s/mtSoxCmds.sh', outDir);
  mtSoxFd = fopen(mtSoxFile, 'w');
  mtPredsFile = sprintf('%s/mtPredictions.csv', outDir);
  mtPredsFd = fopen(mtPredsFile, 'w'); 
  alreadyUsed = zeros(size(score,1), 1);
  for stimulusSet = 1:nsets
    fprintf('writing sox commands and predictions for Stimulus Set %d\n', stimulusSet);
    fprintf(mtSoxFd, '\n# ======= Stimulus Set %2d\n', stimulusSet);
    permutation = randperm(16);
    for dim=1:8
      fprintf(mtSoxFd, '# Dimension %2d\n', dim);
      for pole = [0 1]
	fileID =  permutation((2*dim + pole) - 1);   % map to randomized identifier
	stimFileName = sprintf('stimulus-%d-%02d.wav', stimulusSet, fileID)  ;
	percentile = 1 + 98 * pole;  % 1 or 99
	[ix, alreadyUsed] = findUnusedNearPctl(score, sourceInfo, dim, pole, ...
					       percentile, alreadyUsed);
	clipnum = metad(ix, 4);
	startSeconds = startSecondsForClipnum(clipnum);
	wavFileName = metad(ix,2);
	fprintf(mtSoxFd, 'sox %s %s trim 0:%d 0:30 fade 0 -1 0.01\n', ...
		wavFilePath(wavFileName), stimFileName, startSeconds);
	fprintf(mtPredsFd, '%s, ', stimFileName);
	fprintf(mtPredsFd, '%.3f, ', score(ix, 1:8));  
	fprintf(mtPredsFd, 'source=%s, dim=%d, pole=%d\n', ...
		sourceString(ix, sourceInfo), dim, pole);
      end
    end
  end
  fclose(mtSoxFd);
  fclose(mtPredsFd);
end


function [ix, alreadyUsed] = findUnusedNearPctl(score, sourceInfo, dim, pole,...
						targetPctl, alreadyUsed)
  dimvals = score(:,dim);
  direction = (2 * pole - 1);   % -1 or +1
  stepSize = 0.02;  % percentiles, reasonable, since there are 8227 testset clips
  step = stepSize * direction;  % step towards the pole extreme
  limitPercentile = targetPctl + .8 * direction;    % 0.2 or 99.8
  for percentile = targetPctl:step:limitPercentile
    targetVal = prctile(dimvals, percentile);
    matchDistance = abs(dimvals - targetVal);
    [val, ix] = min(matchDistance);
    %fprintf('# for dim %d: %s is closest to target %5.1f (%2.2f percentile) range %.1f~%.1f\n', ...
    %dim, sourceString(ix, sourceInfo), targetVal, percentile, min(dimvals), max(dimvals));

    if alreadyUsed(ix)
      %%fprintf('clip %2d was already picked as a stimulus,', ix);
      %%fprintf('perhaps for another dimension; looking further\n');
      continue
    end
    if sourceInfo(ix,2) == 1;  % right track is focal, so don't use it
      %%fprintf('skipping a right-track fragment\n');
      continue
      end
    %% it's good!
    alreadyUsed(ix) = 1;
    return
  end
  fprintf('!!! scanned many many candidates with no luck!!! bad!!!\n');
end


function pickClipsForExamination(score, sourceInfo, metad, soxfd)
  Eight = 8; 
  for dim = 1:Eight
    fprintf(soxfd, '# For dim %d: \n', dim);
    for percentileTarget = [.05     .10  .20  .50  .9 .95 .96 .97 .98 .99  1.0 ...
			     1.1 1.2 1.3 1.5 1.7 2.0 3.0 5.0  50   ...
			     99.95  99.9 99.8 99.5  99.4 99.3 99.2 99.1 99 ...
			    98.9 98.8 98.7 98.5 98.3 98  97  95]
      writePercentileExemplar(score, sourceInfo, metad, dim, percentileTarget, soxfd);
    end
  end
end


function writePercentileExemplar(score, sourceInfo, metad, dim, percentileTarget, soxfd)
  Eight = 8; 
  target = prctile(score(:,dim), percentileTarget);
  matchDistance = abs(score(:,dim) - target);
  [val, ix] = min(matchDistance);

  %% if the ix track is right-track focal, and if dim is 2 or 4,
  %%  should find another track, to avoid confusion during interpretation
  %%if sourceInfo(ix,2) == 1 ...

  fprintf(soxfd, '#  %s is closest to target  %5.1f (%.3f percentile), \n', ...
	  sourceString(ix, sourceInfo), target, percentileTarget);
  fprintf(soxfd, '#\t\t  dimvals: %4.1f %4.1f %4.1f %4.1f   %4.1f %4.1f %4.1f %4.1f  \n', ...
	  score(ix, 1:Eight));
  clipnum = metad(ix, 4);   
  wavFileName = metad(ix,2);
  fprintf(soxfd, 'sox %s exemplarDim%dPctle%0.2f.wav trim 0:%d 0:30 fade 0 -1 0.01\n', ...
	  wavFilePath(wavFileName), dim, percentileTarget, startSecondsForClipnum(clipnum));
end 


function startSeconds = startSecondsForClipnum(clipnum)
  %% clip numbers identify 30-second segments from the audio, starting with clip 1
  startSeconds = 30 * (clipnum - 1);
end



function path = wavFilePath(wavFileName)
  path = sprintf('/cygdrive/f/nigel/comparisons/en-swbd/disc?/wavfiles/sw0%4d.wav', ...
		 wavFileName);
end
			       


%% for subsets of different sizes,
%%   for each dim of coeff (loadings on each dim)
%%   report the cosine distance to the closest dimension in the subsetCoeff
%%     that is, the PCA loadings for the dimensions obtained with the subset
function compareWithSubsets(coeff, normalized)
  fprintf('Computing match to final dimensions as a function of time\n');
  fprintf('... see the plot for visualization\n');

  nsides = size(normalized, 1);
  nslices = 25;
  for numberOfSlices = 1:nslices
    percentage = 1.0/nslices * numberOfSlices;
    subset = normalized(1:round(percentage*nsides),:);
    subset = (subset - mean(subset)) ./ std(subset);   %% this helps a little
    [subsetCoeff, score, latent] = pca(subset);  
    for wholeSetDim=1:8
      %% fprintf('for whole set dim %d, cosines with subset dims:\n', wholeSetDim);
      cosines = zeros(1,8);
      for subsetDim=1:round(0.5 * size(subsetCoeff,2))
	%% don't even consider those in the lower half
	%% should report dim in subsetCoeff with highest cosine
	cosines(subsetDim) = absCosine(coeff(wholeSetDim,:), ...
				       subsetCoeff(subsetDim,:));
      end
      [m,d] = max(cosines);
      %%  fprintf(' %.2f at subsetDim %d \n', m,d);
      bestCosine(numberOfSlices, wholeSetDim) = m;
    end
  end

  clf('reset'); % clear figure 
  plot(bestCosine(:,1), '-+k');
  hold on 
  plot(bestCosine(:,2), '--og');
  plot(bestCosine(:,3), ':*r');
  plot(bestCosine(:,4), '-.xb');
  legend('dim 1', 'dim 2', 'dim 3', 'dim 4');
  axis([0 nslices 0 1]);
end


function ac = absCosine(vec1, vec2)
  ac = abs(dot(vec1, vec2) / (sqrt(dot(vec1, vec1)) * sqrt(dot(vec2, vec2))));
end


%% how do males and females differ?
%%   on what dimensions do they differ? and is it significant?
function examineMaleFemale(score, metad)
  GenderField = 6;
  femaleSides = ismember(metad(:,GenderField), 1);
  femaleDimvals = score(femaleSides,1:8);
  maleDimvals = score(~femaleSides,1:8);
  fprintf('\nGender comparison: for %d male sides and %d female sides\n', ...
	  length(maleDimvals), length(femaleDimvals));  
  fprintf('  male means      %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', mean(maleDimvals));
  fprintf('  female means    %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', mean(femaleDimvals));
  fprintf('  effect size     %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', ...
	  ((mean(femaleDimvals) - mean(maleDimvals)) ./ std(score(:,1:8))) );
  fprintf('\n')
  dlmwrite('dimvals.txt',   maleDimvals', 'delimiter', ',', '-append');
  dlmwrite('dimvals.txt', femaleDimvals', 'delimiter', ',', '-append');
  %% open in excel, clear column at left, then insert t-tests, dim1m vs dim1f etc.
  %% = ttest(b1:xfd1, b9:xfd9, 2, 3), etc. unmatched t-tests
end


function examineAB(score, metad)
  abField = 3;
  aSides = metad(:,abField)==1;
  bSides = metad(:,abField)==0;
  aDimvals = score(aSides,1:8);
  bDimvals = score(bSides,1:8);
  fprintf('Side comparison: for %d A sides and %d B sides\n', ...
	  length(aDimvals), length(bDimvals));
  fprintf('  A means    %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', mean(aDimvals));
  fprintf('  B means    %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', mean(bDimvals));
  fprintf('  effect size     %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', ...
	  ((mean(aDimvals) - mean(bDimvals)) ./ std(score(:,1:8))) );
  dlmwrite('dimvals.txt', aDimvals', 'delimiter', ',', '-append');
  dlmwrite('dimvals.txt', bDimvals', 'delimiter', ',', '-append');
%  fprintf('  p values ');
%  for dim = 1:8
%    [h,p] = ttest(aDimvals(:,dim), bDimvals(:,dim));
%    fprintf(' %.3f', p);
%    end 
%  fprintf('\n');
end

%% stage in the dialog: early or late 
function examineStage(score, metad)
  clipNumField = 4;
  meanClipNum = mean(metad(:,clipNumField));
  fprintf('          (meanClipnum was %.1f)\n', meanClipNum);
  laterVec = metad(:,clipNumField) > meanClipNum;
  earlierVec = metad(:,clipNumField) <= meanClipNum;
  laterDimvals = score(laterVec,1:8);
  earlierDimvals = score(earlierVec,1:8);
  fprintf('Stage comparison: for %d early fragments and %d late fragments\n', ...
	  length(earlierVec), length(laterVec));  
  fprintf('  earlier means    %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', mean(earlierDimvals));
  fprintf('  later   means    %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', mean(laterDimvals));
  fprintf('  effect size     %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', ...
	  ((mean(laterDimvals) - mean(earlierDimvals)) ./ std(score(:,1:8))) );
  dlmwrite('dimvals.txt', earlierDimvals', 'delimiter', ',', '-append');
  dlmwrite('dimvals.txt', laterDimvals', 'delimiter', ',', '-append');
end


function examineAge(score, metad)
  BirthYearField = 7;

  meanBirthYear = mean(metad(:,BirthYearField));
  olderVec = metad(:,BirthYearField) < meanBirthYear;
  oldDimvals = score(olderVec,1:8);
  youngDimvals = score(~olderVec,1:8);
  fprintf('Age comparison: for %d young sides and %d old sides\n', ...
	  length(youngDimvals), length(oldDimvals));  
  fprintf('  young means    %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', mean(youngDimvals));
  fprintf('  old   means    %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', mean(oldDimvals));
  fprintf('  effect size     %5.2f %5.2f %5.2f %5.2f   %5.2f %5.2f %5.2f %5.2f  \n', ...
	  ((mean(oldDimvals) - mean(youngDimvals)) ./ std(score(:,1:8))) );
  dlmwrite('dimvals.txt', oldDimvals', 'delimiter', ',', '-append');
  dlmwrite('dimvals.txt', youngDimvals', 'delimiter', ',', '-append');


% a trifle slow 
%  clf('reset'); % clear figure 
%  for dim=1:8
%    scatter(metad(:,BirthYearField), score(:,dim));
%    correlation = corrcoef(metad(:,BirthYearField), score(:,dim)); 
%    fprintf('birth-score correlation for dim %d is %.2f\n', ...
%	    dim, correlation(1,2));
%    pause(1);
%  end
end


%% metad parallels sstats and score.   Each row has 
%% 1=key, 2=filenum, 3=side, 4=clipNum, 5=speakerId, 6=isFemale, 7=birthyear, 8=topicID
function metad = assembleMetadata(basedir, sourceInfo)
  nsides = length(sourceInfo);
  metad = zeros(nsides, 8);
  metad(:,1) = 10 * sourceInfo(:,1) + sourceInfo(:,2);  % keys encode dialog and side
  metad(:,2:4) = sourceInfo(:,:);

  fromLDC = readmatrix([basedir 'swbd-various/metadata.txt']); % created by prepMetadata.sh
  toJoin = zeros(length(fromLDC), 7);
  toJoin(:,1) = 10 * fromLDC(:,1) + fromLDC(:,2);  % keys
  toJoin(:,2:7) = fromLDC;

  for i = 1:nsides
    idx = ismember(toJoin(:,1), metad(i,1));
    metad(i,5:8) = toJoin(idx,4:7);
  end
end 
		

function n = NSourceInfoFields()
  n = 3;  % there are 3 info fields: file ID, track number, clip number
end


function str = labelString(i, featNames)
  labelCell = featNames(i);
  str = labelCell{1};
end


function writeLoadingsTable(coeff, featuresCellArray, header, outdir)
  pdimNames = {'self has turn', 'other has turn'; ... 
	       'silence', 'overlap'; ...
	       'turn take', 'turn yield'; ...
	       'backchannel cueing', 'backchannelling'; ...
	       'topic closing', 'topic continuation'; ...
	       'topic development', 'positive assessment'; ...
	       'empathy bid', 'indifference'; ...
	       'turn-hold fillers', 'bipartite construction'; ...
	       'long turn take', 'long turn yield'; ...
	       'late peaks', 'turn-initial fillers'; ...
	       'meta comment', 'bookended narrow pitch'; ...
	       'minor third cue' 'receiving action cue'; ...
	      };

  numberToWrite = min(length(coeff),12);
  intervals = intervalsForCSP();

  lfd = fopen([outdir 'loadingsTables.txt'], 'w');
  fprintf(lfd, '%s\n', header);

  for dim = 1:numberToWrite
    fprintf(lfd, '\nIS Dimension %d   ', dim);
    for i = 1:length(intervals)
      fprintf(lfd, "%.1f~%.1f ", intervals(i,1), intervals(i,2));
    end
    fprintf(lfd, '\n');
    for featType = 0:(length(coeff) / 7) - 1 
      lowNameCell = pdimNames(featType + 1, 1);
      highNameCell = pdimNames(featType + 1, 2);
      fprintf(lfd, '\n%17s ', lowNameCell{1});
      fprintf(lfd, '%5.2f %5.2f %5.2f  %5.2f  %5.2f %5.2f %5.2f ', ...
	      coeff(featType * 7 + 1 : featType * 7 + 7, dim));
      fprintf(lfd, ' %s\n', highNameCell{1});
    end
  end
  fclose(lfd);
end


%% ---------------------- dead code below this point --------------------


%% to analyze turn-taking styles only, can interpolate these lines in
%% the main function just above normalization
%  turnTakingRelated = [1 2 3 4 9 12];
%  turnTakingRelatedMask = [1 1 1 1 1 1 1    1 1 1 1 1 1 1  1 1 1 1 1 1 1 ...
%  			     1 1 1 1 1 1 1  0 0 0 0 0 0 0  0 0 0 0 0 0 0 ...
%			     0 0 0 0 0 0 0  0 0 0 0 0 0 0  1 1 1 1 1 1 1 ...
%			     0 0 0 0 0 0 0  0 0 0 0 0 0 0  1 1 1 1 1 1 1];
%  %%TEMPORARY, TO GET DIMENSIONS RELATING ONLY TO TURN-TAKING
%  sstats = sstats(:, turnTakingRelatedMask==1);
%  featNames = featNames(turnTakingRelatedMask==1);


%% OBSOLETE     (replaced by pickClipsForHumanSubjects and picClipsForExamination)
%% write a file listing the most extreme clips for each pole, for listening
function writeISexemplars(score, sourceInfo)
  fprintf('writing exemplars ... ');
  dimsToShow = 10; 
  exemplarsToWrite = 100;
  de = fopen('dimExemplars.txt', 'w');
  fprintf(de, 'Interaction Style Dimension %s\n', datestr(clock));
  for dim = 1:dimsToShow
    dimSlice = score(:, dim);
    nsides = length(dimSlice);
    [vals, sortIndices] = sort(dimSlice);
    fprintf(de, '\n for dim%2d pos:\n', dim);
    for i=0:exemplarsToWrite
      fprintf(de, '%s  %.1f\n', ...
	      sourceString(sortIndices(nsides-i), sourceInfo), vals(nsides-i));
    end
    fprintf(de, '          neg:\n', dim);
    for i=1:exemplarsToWrite
      fprintf(de, '%s  %.1f\n', sourceString(sortIndices(i), sourceInfo), vals(i));
    end
  end
  fprintf(de, '\n');
  fclose(de);
  fprintf('... done \n');
end



%% return only sides that are within the threshold number of
%%   standard deviations on all dimensions
function [pruSstats, pruSourceInfo] = pruneExcessives(sstats, sourceInfo, featNames)
  for feat = 1: size(sstats, 2)
    histogram(sstats(:,feat))
    title(labelString(feat, featNames));
    pause(2);
  end

  fprintf('pruneExcessives\n');
  threshold = 25;   %  need to set sensibly!!!
  sstatsStdDevs = std(sstats);
  excessiveStatMatrix = sstats > abs(mean(sstats) + threshold * sstatsStdDevs);
  %% a boolean column vector with 1 for no-good sides
  excessives = sum(excessiveStatMatrix, 2) > 0;  
  for side = 1:size(sstats,1)
    if excessives(side) 
     %%fprintf('%s is excessive: exceeds %.1f stds on stats: \n          ', ...
%	      sourceString(side, sourceInfo), threshold);
      for feat = 1:size(sstats, 2)
	if excessiveStatMatrix(side, feat)
	  %% assume the mean is not significantly off zero
	  fprintf(' %d %s (%s) (%.2f, %.2f std devs, mean is %.4f, std is %.2f)  \n', ...
		  feat, sourceString(side, sourceInfo), ...
		  labelString(feat, featNames), sstats(side,feat), ...
		  sstats(side,feat) / std(sstats(:,feat)), ...
		  mean(sstats(:,feat)), std(sstats(:,feat)) );
	end
      end
    end
  end
  fprintf('pruning %d sides since excessive on some statistic\n', sum(excessives));
  pruSstats = sstats(excessives==0,:);
  pruSourceInfo = sourceInfo(excessives==0,:);
end


%% flag sides that exceed the threshold number of stds on some istyles dimensions 
function warnReExcessives(score, sstats, sourceInfo, featNames)
  Eight = 8;
  threshold = 15;   % arbitrary
  excessiveDimMatrix = abs(score) > mean(score) + threshold * std(score);
  excessiveDimMatrix = excessiveDimMatrix(:,1:Eight);
  %% a boolean column vector with 1 for no-good sides
  excessives = sum(excessiveDimMatrix, 2) > 0;  
  for side = 1:length(score)
    if excessives(side) 
      fprintf('Warning: %s is excessive: exceeds %.1f stds on dimensions: \n          ', ...
	      sourceString(side, sourceInfo), threshold);
      for dim = 1:Eight
	if excessiveDimMatrix(side, dim)
	  fprintf(' %d (%.2f, %.2f std devs)  ', ...
		  dim, score(side,dim), score(side,dim) / std(score(:,dim)));
	end
      end
      fprintf('\n');
    end
  end
end


function printEightNumbers(label, numbers)
  fprintf('        %7s ', label);
  fprintf('%6.2f', numbers(1:4));
  fprintf('  ');
  fprintf('%6.2f', numbers(5:8));
  fprintf('\n')
end
